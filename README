# DevOps-Docker-Kubernetes
# Docker: docker_folder

### Overview

This repository contains various scripts and configurations for managing and automating DevOps tasks using Docker, Kubernetes, AWS, and Ansible. Each folder is organized by technology and contains necessary scripts, configurations, and instructions to set up and manage resources efficiently.

### Dependencies:

    Python 3.7
    Docker Python SDK
    Docker
    Docker Compose
    os module (used in Part 2)

### Setup:

1. Create a Python virtual environment in each directory containing the Dockerfile and Python script.
2. Install necessary packages using pip, including the Docker Python SDK.

### Running Docker Interactively:

To run the Dockerfile interactively, use the command:

```bash

sh

docker run -it -v /var/run/docker.sock:/var/run/docker.sock [IMAGE_NAME]:[TAG]

```


This mounts the Docker daemon socket, allowing the container to communicate with the Docker daemon on the Amazon-Linux host.

### Downgrading urllib3:

The urllib3 version was incompatible with the system environment, so it was downgraded using:

```bash
sh

python3 -m pip install "urllib3<2.0"
```

### Interactive Menu:

The program outputs an interactive menu using the Docker Python SDK with options to:

    List all containers.
    List all stopped containers.
    Select an image to create and run a new container.
    Execute a command in a selected container.
    View port mappings of a selected container.
    Stop and remove all containers.
    Save an image to a tar file.

### Files: menu.py, requirements.txt, dockerfile

### Dockerfile Creation and Execution:

The 'create_dockfile.py' script generates a Dockerfile to run a Python script (example.py), which outputs text in the terminal.

### Directory: 'my_files'
### Files: create_dockfile.py, requirements.txt, example.py

# Docker Compose for Pre-Defined Scenario:

A multi-container Docker Compose setup for a complex web application including databases, Redis cache, and a Flask application.

### Directory: dock_comp

### Files: Docker-compose.yml, Requirements.txt, env_file

### Example:
Modified from juggernaut's example, adding and modifying containers for a 7-container setup including Flask, Nginx, PostgreSQL, Redis, BusyBox, and Alpine.
Running Docker Compose:

Images and containers are pulled and run as specified in the docker-compose.yml. The docker ps command confirms successful container deployment.

# Kubernetes: kubernetes_folder

### Dependencies:

    Kubernetes cluster setup using kubectl, kubeadm, and kubelet.
    Kubernetes Python SDK installed via pip.

### Kubernetes Interactive Menu:

A Python script providing an interactive menu to manage Kubernetes resources using the Kubernetes Python SDK.

### Directory: kubernetes

### Files: load-balancer-service.yaml, My_kube.py, pods.yaml

### Kubernetes Menu Options:

    List all pods.
    Describe a pod.
    Create a deployment.
    Scale a deployment.
    Execute a command on a pod.
    Create a rolling update.
    Delete a deployment.
    Create pods on every worker node.

### Load Balancing Service and Multiple Pods:

Functions to apply YAML configurations for deploying a load-balancing service and multiple pods.

### Functions Used:

    apply_yaml(): Applies YAML files for deployments and services.
    list_pods(): Outputs a list of pods.
    list_services(): Lists running services.
    create_kube_resources(): Combines functions to create resources and outputs their names.

# AWS Resources: folder_aws_resource_functions

### Files containing functions to create, delete, and modify AWS resources:

    autoscale.py
    awsmanager.py
    cwcontroller.py
    ebsmanager.py
    lambhandler.py
    newuser.py
    rdscontroller.py
    S3controller.py
    registeruser.py
    main.py (menu to interact with the AWS resources)

# Ansible: folder_aws_resource_functions/ansible
File: play1.py

Prompts the user to input the number of instances to launch and the name of the Ansible group.

    Validates the number of instances (must be between 1 and 5).
    Creates EC2 instances with specified parameters such as image ID, instance type, key pair, security group, and subnet.
    Waits until the instances are running and retrieves their public IP addresses.
    Writes the group name and IP addresses to a file named groups_ip.txt and sets its permissions to 600.
    Executes an Ansible playbook using the generated inventory file.

File: playbook2.yaml

Installs and configures Apache2 on a selected group of hosts. It prompts the user for the target group of hosts and ensures that Apache2 is installed, running, and enabled on boot. The playbook is designed to work on Debian-based systems and requires sudo privileges to execute the tasks.
Example Run:

```bash
sh

ansible-playbook apache_install.yaml
```